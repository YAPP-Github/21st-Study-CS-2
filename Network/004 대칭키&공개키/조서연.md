### 대칭키(Symmetric Key)

암호화와 복호화에 같은 암호키를 사용한다.

- 키를 아는 사람은 문서를 복호화하여 볼 수 있다.
- 속도가 빠르다.
- 키를 교환 과정이 필요하다.
    - 교환 중 키가 탈취될 수 있다.
- 관리해야 할 키가 방대해질 수 있다. (공개키 방식은 자신의 개인키 하나로 메시지를 복호화할 수 있으므로 자신의 개인키만 관리하면 된다.)
- 기밀성은 제공하지만 무결성/인증/부인 방지를 보장하지 않는다.
    - 기밀성: 오직 인가된 당사자(사용자/프로세스/시스템)만이 접근해야 한다.
    - 무결성: 정보는 고의적인/비인가된/우연한 변경으로부터 보호되어야 한다. 즉 인가된 사용자가 인가된 방법으로만 변경해야 한다.
    - 인증: 정당한 사용자임을 확인
    - 부인방지: 송수신 참여 당사자가 행위를 부인할 수 없다. 송수신 사실에 대한 행동을 추적해서 부인할 수 없도록 한다.
- 스트림 암호: 연속적인 비트/바이트를 입력받아, 이에 대응하는 암호화 비트/바이트를 생성하는 방식
- 블록 암호: 정해진 단위(블록)를 입력받아 대응되는 암호화 블록을 생성하는 방식
- 대표적인 알고리즘: SEED, DES, 3DES, AES, ARIA

### 공개키/개인키(Public Key/Private Key), 비대칭키(Asymmetric Key)

암호화 키와 복호화 키를 분리하여 사용한다.

- 공개키는 공개되어 있어 누구든 접근할 수 있고, 각 사용자가 개인키를 갖는다.
- 공개키가 공개되어있기에 키 교환이나 분배가 필요없다.
- 개인키를 가진 수신자만이 암호화된 데이터를 복호화할 수 있으므로 일종의 인증 기능도 한다.
- 속도가 느리다.
- 대표적인 알고리즘: Diffie Hellman, RSA, DSA, ECC

![image](https://user-images.githubusercontent.com/67777523/212075887-d603ae53-24ac-46aa-85e7-cf3d8a4114dc.png)


A에서 B로 데이터를 보낸다고 가정해보자.

1. B의 공개키와 개인키 쌍을 생성한다.
2. B의 공개키는 공개하고, 개인키는 자신이 보유하고 있는다.
3. A가 B의 공개키를 얻는다.
4. A가 데이터를 B의 공개키를 사용해 암호화한다.
5. 암호화된 데이터를 A에서 B로 전송한다.
6. B가 암호화된 데이터를 자신의 개인키로 복화화한다.

### SSL, Secore Sockets Layer

- 네트워크에서 메시지 전송시 웹 서버와 웹 브라우저간의 보안을 위해 개발된 프로토콜이다.
- SSL은 공개키 방식과 대칭키 방식을 혼합하여 사용한다.
- 응용계층에서 만들어진 메시지가 전송계층으로 이동하기 전 SSL을 통해 암호화된다.

네트워크를 통해 서버에 요청을 주고 받을 때 수 많은 라우터와 스위치를 거치게 된다. 이 과정에서 누군가가 패킷을 훔쳐보게 될 수 있다. 그래서 데이터를 암호화하여 중간에 공격자가 패킷을 열람하더라도 데이터가 유출되는 것을 막는다. HTTP의 경우 중간에 패킷을 가로채면 데이터가 누출될 위험이 있다. 그래서 SSL 보안 통신을 사용하는 HTTPS를 사용한다.

실제 **전송되는 데이터의 암호화에는 대칭키를 사용**하고, **키 교환에는 비대칭키를 사용**한다. 즉 두 가지 암호화 방식을 같이 사용하여 효율적이면서 누출 위험은 줄이는 방식으로 동작한다. 

1. A가 B에게 접속 요청을 한다.
2. B는 자신의 공개키를 A에게 보낸다.
3. A가 B의 공개키를 사용해서 앞으로 통신에 사용할 대칭키를 암호화하여 B에게 보낸다. (대칭키를 공개키로 암호화)
4. B는 공개키로 암호화된 암호문을 받아 자신의 개인키로 복호화한다.
5. B는 복호화한 대칭키를 사용하여 A에게 보낼 데이터를 암호화하고, A에게 보낸다.
6. A는 자신의 대칭키로 암호문을 복호화한다.
