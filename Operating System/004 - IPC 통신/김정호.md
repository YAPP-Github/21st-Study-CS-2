- 동시에 실행하는, 정확히는 시분할 시스템을 통해 동시에 실행하는 것처럼 보이는 많은 프로레스들은 서로 **독립적인 프로세스**일 수도, **협력적인 프로세스**일 수도 있다.
    - **독립적인 프로세스**의 경우 다른 프로세스와 **공유할 데이터가 없다.**
    - **협력 프로세스**의 경우 다른 프로세스와 **데이터를 공유**하며 서로에게 영향을 주거나 받을 수 있다.
- 서로 협력하는 프로세스들은 수행 과정 중 다른 프로세스와 정보를 공유하기 위해 방법을 모색해야 한다.

## 프로세스 간 협력이 필요한 이유

- **정보 공유** - 여러 사용자가 동일한 정보를 필요로 할 수 있다.
- **계산 속도 증가** - 특정 작업을 빠르게 실행하고자 할 때 해당 작업을 여러 서브 태스크로 나누어 각각 다른 서브 태스크들과 병렬로 실행하게 할 수 있다.
- **모듈화** - 특정 시스템 기능을 별도의 프로세스로 구분하여 모듈식 형태로 시스템을 구성할 수 있다.
- **편의성** - 여러 사용자들이 동시에 많은 작업을 수행할 수 있다.

 

## IPC 통신

![image](https://user-images.githubusercontent.com/85336456/205069888-114b09d2-8317-4a6b-b99a-aaeeed033808.png)

- **프로세스**들은 주소 공간이 분리되어 있는, **완전히 독립된 실행 객체**이다.
    - 서로 독립되어 있어 다른 프로세스의 영향을 전혀 받지 않는다는 장점이 있다. **(안전성)**
    - 그러나 독립되어 있는 것으로 인해 **별도 장치 없이는 프로세스 간 협력이 어렵다.**
- 프로세스 사이의 통신을 지원하기 위해 **커널에서 IPC 메커니즘을 제공**하고, **프로세스는 이 IPC 메커니즘을 통해 프로세스 간 통신을 할 수 있게 된다.**

### **🤔 단순하게 파일을 통한 정보 공유는 어려울까?**

- 보조 저장 장치인 파일을 통해 각각 프로세스들이 정보를 공유하는 방법은 왜 프로세스 간 통신에서 사용되지 않을까?
    - 공유되는 파일을 각 프로세스가 동기화 되어져서 처리될 수 있도록, 즉 순서대로 처리해서 **데이터 불일치를 방지**해야 한다.
    - 데이터 불일치를 해결하며 각 프로세스가 파일을 통해 정보를 공유하더라도 파일은 메모리에 비해 상대적으로 느린 보조 저장 장치에 저장되어지는 데이터라 **파일을 통한 정보 공유는 효율적이지 못하다.**
- 정보를 좀 더 효율적으로 공유하기 위해 보조 기억 장치가 아닌 주기억장치, 즉 메모리를 통해 정보를 공유해야 한다.

## IPC 통신의 종류

![image](https://user-images.githubusercontent.com/85336456/205069961-d2c56415-a64e-4e79-bcf9-656454a188f5.png)

- **IPC 모델**은 크게 2가지가 존재한다.
    - **공유 메모리 방식(Shared Memory)** - **데이터를 완전히 공유하여 함께 사용하는 방법**
    - **메시지 패싱 방식(Message Passing)** - **통신을 이용해 데이터를 주고받는 방법**

### **공유 메모리 모델의 IPC 통신**

![image](https://user-images.githubusercontent.com/85336456/205069995-528a5b06-48a1-4396-ab9e-7c259572f01f.png) 

- 최초 공유 메모리 영역을 생성하려는 프로세스가 공유 메모리 할당을 커널에 요청하면, **커널은 해당 프로세스에 메모리 공간을 할당**해준다.
- 이후 해당 메모리 영역은 **커널에 의해 관리**되며, **어떤 프로세스든 해당 메모리 영역에 접근할 수 있게 된다.**
    - **커널**에 의해 관리되기 때문에 컴퓨터를 다시 시작하거나, 직접 공유 메모리 영역을 해제하지 않는 이상 **공유 메모리 영역을 사용하는 모든 프로세스가 종료되더라도 유지**된다.

**장점**

- **IPC 기법 중 처리 속도가 가장 빠르다.**
    
    ⇒ 다른 IPC 기법과 달리 **메모리 자체를 공유**하므로 데이터 복사와 같은 불필요한 오버헤드가 발생하지 않기 때문이다.
    
- 해당 프로세스가 CPU를 사용하는 행위이므로, **적은 컨텍스트 스위칭 비용**을 자랑한다.

**단점**

- **같은 장치 위에 존재하는 프로세스들 간에만** 공유 메모리 사용이 가능하다.
- 네트워크 사용이 불가능하다.
- 여러 프로세스가 같은 메모리 영역에 접근하므로 **데이터 불일치 문제를 해결**해야 한다.
- 구현이 어렵다.

### 메시지 패싱 모델의 IPC 통신

![image](https://user-images.githubusercontent.com/85336456/205070050-ecb09af7-a4dd-441f-a5ff-3c833a218615.png)

- 공유 메모리 방식은 모든 프로세스가 하나의 공간을 같이 쓰는 개념이라면, **메시지 패싱 방식은 공유 자원이 필요할 때마다 프로세스 사이에서 전달하는 방식**이다.
- 커널이 메모리 보호를 위해 필요한 자원을 대신 전달해준다.

- 메시지 패싱 방식은 크게 다이렉트 커뮤니케이션과 인다이렉트 커뮤니케이션으로 나뉜다.
    
    ![image](https://user-images.githubusercontent.com/85336456/205070064-0277fea6-80fe-4cd2-a447-393f17a6707e.png)
    
- **다이렉트 방식**
    - 통신하고자 하는 **상대방이 누구인지 명확하게 알 수 있을 때** 주로 사용한다.
    - A 프로세스에서 커널에 메시지를 직접 주면, 커널이 B 프로세스에게 메시지를 **직접** 전달한다.
    - 대부분 **양방향, 일대일 관계**로 구성된다.
    - 상대방의 이름이 달라지면 문제가 발생할 수 있다.
- **인다이렉트 방식**
    - **상대방이 명확하지 않을 때 사용하며**, 매개체를 필요로 한다.
    - A 프로세스에서 커널의 포트에 메시지를 넣어두면, **불특정 프로세스**가 해당 포트에 접근하여 메시지를 읽어간다.
    - 포트를 이용해 통신하므로 **다대다 관계**가 구성될 수 있다.

**장점**

- 메모리를 같이 쓰는 개념이 아니므로 동기화 문제를 고민할 필요가 없다.
- 구현이 쉽다.

**단점**

- 커널을 통해 데이터를 전달하므로 속도가 느리다.
- 속도가 느리므로 보낼 수 있는 데이터의 양 역시 제한된다.

### 메시지 패싱 모델의 예시 - Pipe

![image](https://user-images.githubusercontent.com/85336456/205070148-2ad02e7d-1ae0-47be-b7ff-e30137a3bc3a.png)

- **통신을 위한 메모리 공간**을 이용하여 프로세스가 데이터를 서로 주고 받는다.
- 파이프는 기본적으로 **한쪽 방향으로만 통신이 가능**해 Half-Duplex 통신이라고도 부른다.
    - 만약 송/수신이 모두 가능한, Full-Duplex 통신을 원한다면 파이프를 하나 더 생성해주어야 한다.
    - 그러나 파이프를 하나 더 생성하는 것은 낭비가 심하므로 좋지 않은 선택이 될 수 있다.

- 파이프는 용도에 따라 익명 파이프, 네임드 파이프로 나눌 수 있다.

- **익명 파이프(Anonymous PIPE)**
    - 일반적인 파이프로, 부모 자식간의 관계와 같이 **통신 대상 프로세스가 명확할 경우 사용**한다.
    - 간단하게 사용이 가능하지만, 외부 프로세스는 사용이 불가능하다는 단점이 있다.

- **네임드 파이프(Named PIPE)**
    - **통신 대상 프로세스가 명확하지 않을 때 사용**하며, FIFO 라 불리는 특수 파일을 이용한다.
    - 익명 파이프와 달리 **서로 관련 없는 프로세스 간 통신이 가능**하다. 즉, 외부 프로세스와 통신이 가능하다.

### 메시지 패싱 모델의 예시2 - Message Queue

![image](https://user-images.githubusercontent.com/85336456/205070170-82350737-ee0b-467a-91b3-0a7a15bec522.png)

- 선입선출 데이터 구조인 **큐**를 통해 메시지를 주고 받는 기법이다.
- 입출력 방식은 **네임드 파이프와 동일**하다.
- **파이프는 스트림** 기반으로 동작하지만, **메시지 큐는 메시지 단위**로 동작한다.

- **서로 관련 없는 프로세스 간 통신이 가능**하다.
- 메시지 큐에 데이터를 담을 때 번호(타입)을 붙이기 때문에 여러 프로세스가 필요한 데이터를 쉽게 추출할 수 있다.
- 전송부와 수신부로 나뉘어 **양방향 통신이 가능**하다.

### 메시지 패싱 모델의 예시3 - Socket

![image](https://user-images.githubusercontent.com/85336456/205070203-3b54af15-4a40-4261-87c4-77c31c876370.png)

- 소켓은 **네트워크상에서 동작하는 프로그램 간 통신의 종착점**을 의미한다. 즉, **프로그램이 네트워크 사이에서 통신하도록 도와주는 연결고리 역할을 수행**한다.
    
    > Endpoint : IP 주소, 포트 번호의 조합을 뜻하며 최종 목적지를 나타낸다.
    > 

- 기본적으로 **시스템 내부 혹은 시스템 외부의 다른 프로세스와 네트워크 통신을 하기 위해 사용**된다.
    - 즉, PC 내 두 프로세스 간 통신 기법으로도 사용이 가능하다는 것이다.
- 프로세스는 포트 번호를 이용하여 통신하려는 상대 프로세스의 소켓을 찾아간다.
- 파이프와 같이 **일대일**로 데이터를 주고 받는다.
- **양방향** 통신이 가능하다.

### 메모리 맵을 이용한 IPC 통신

- **공유 메모리와 마찬가지로 메모리를 공유한다는 점에서 비슷**하다.
- 그러나 **메모리 맵의 경우 열린 파일을 메모리에 매핑시켜 공유한다는 차이**가 있다. (파일 + 메모리)
- 주로 파일로 대용량 데이터를 공유할 때 사용한다.
