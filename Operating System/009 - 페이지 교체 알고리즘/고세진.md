# 페이지 교체 알고리즘과 스레싱

가상 메모리를 통해 물리 메모리보다 큰 프로세스를 실행할 수 있지만, 여전히 물리 메모리 크기는 한정되어 있다. 따라서 페이지 폴트가 발생하게 되고, 디스크에서 페이지를 읽어올 때 빈 프레임이 없다면 중요도가 떨어지는 페이지를 보조기억장치로 swap out 시키는데, 이때의 정책을 페이지 교체 알고리즘이라고 한다.

페이지 교체 알고리즘의 목적은 페이지 폴트를 최소화하는것임. 

### demand paging (요구 페이징)

실행에 요구되는 페이지만 메모리에 적재하는 기법

1. CPU가 특정 페이지에 접근하는 명령어를 내림
2. 페이지의 유효 비트가 1인 경우, 페이지가 적재된 프레임에 접근
3. 유효 비트가 0이면, 페이지 폴트 발생
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 변경
5.  다시 1번을 수행

참고) 아무런 페이지도 적재하지 않은 채 무작정 실행하는 경우를 순수 요구 페이징 (pure demand paging)이라고 한다.

### 페이지 교체 알고리즘

페이지 폴트 횟수를 알아야 페이지 교체 알고리즘을 이해할 수 있고, page reference string을 통해 페이지 폴트 횟수를 알 수 있음.

cpu가 페이지에 2 2 2 3 5 5 5 5 3 3 7 처럼 접근시 2 3 5 3 7이 page reference string이 된다.

### FIFO 페이지 교체 알고리즘

- first in first out, 가장 먼저 올라온 페이지부터 내쫒는다.

### Optimal 페이지 교체 알고리즘

- 얖으로 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘 → 앞으로 어떤 페이지가 사용될지 예측이 어려워 구현이 어려워 다른 페이지 교체 알고리즘의 성능을 평가하기 위한 목적으로 사용

### LRU 페이지 교체 알고리즘

- Least Recently Used 를 쫒아낸다.
- 최근에 가장 적게 사용된 것을 쫒아낸다.
    - 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 아이디어

### LRU  - 카운터

- cpu의 타임스탬프를 기록한다.
    - cpu가 메모리에 접근할 때마다 증가하는 logical clock을 사용함
- 타임스탬프를 기록하는 오버헤드, 페이지테이블에서 타임스탬프의 min을 찾는 오버헤드가 필요하다.
- 기록도 해야하고 Fault 날때마다 O(N) 필요

### LRU  - 스택

- 더블 링크드 리스트로 스택처럼 만든다. 최근에 사용한 페이지 번호를 위쪽으로 보내다보면, 가장 아래쪽은 나중에 사용한 것이므로 victim으로 선정할 수 있다.
- 한 번 참조시 포인터 6개를 변경해야함.  → 오버헤드 크다

### LRU 근사 - reference bit

- 각 페이지가 참조됐으면 1, 안됐으면 0으로 쓴다.
- 주기적으로 0으로 초기화한다.
- 0 중에서 빅팀을 고른다 → 성능이 별로임 ( 언제 접근했는지 모름)

### LRU 근사 - additional reference bit

- 8개의 비트를 써서 레퍼런스 비트로 쓰고, 주기적으로 비트를 오른쪽으로 shift한 다음 MSB에 0을 추가.
- 결국 min을 써야하고 8비트라는 공간도 차지해서 오버헤드 큼.

### LRU 근사 - 클락알고리즘

- 모든 페이지를 circular 큐로 관리
- next victim 포인터가 다음 빅팀을 가리킨다.
- 빅팀의 레퍼런스가 0이면 빅팀으로 선정하고, 1인경우 0으로 바꾼다음 포인터를 앞으로 보낸다.
- 한번 사용했을 경우 0으로 바꾸고, 다시 돌아왔을 때에도 0이면 별로 안 쓴다는 아이디어
- 레퍼런스 비트와 비교했을 때
    - 포인터의 이동순서가 정해져있어서 누가 오래됐는지 알 수 있음
    - 방금 내가 0으로 바꾼 것과, 그것보다 앞에서 0으로 바꾼건 순서가 있음.
    - 스페이스도 레퍼런스빗 하나랑 포인터하나라서 저렴하고 , min 을 구하지 않아도 되서 오버헤드 적음
    
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4adf3f0-25f8-4cf3-a82a-65bb44972069/Untitled.png)
    

### LFU (Least Frequently Used)

- 과거에 참조횟수가 가장 적은 페이지를 교체시킬 페이지로 결정
- 접근 시점을 고려하지 말자는 알고리즘 (LRU는 아주 많이 접근 된 녀석도 잠깐 접근 안하면 out시켜버림)

### 기타

### 스레싱과 프레임 할당

알고리즘 문제가 아니더라도, 프레임이 적으면 페이지 교체가 많이 일어난다.

스래싱 : 페이지 폴트가 많이 발생하여(io가 많이 발생하여) CPU 사용률이 저해되는 현상

- 프로세스가 많아지면 CPU 사용률이 증가하다가 페이지 IO를 많이 처리하므로 CPU 사용률이 줄어든다. 이 때, CPU 사용률이 증가되면 mid-term 스케줄러가 사용률을 높이기 위해 다른 프로세스를 시스템에 추가시켜서 Multi programming degree를 증가시킨다. 따라서 기존의 프로세스에  할당된 프레임을 더 나눠서 배분해야하고, page fault rate가 더 증가해 결국 cpu 사용률이 심각하게 떨어진다.

- 스래싱의 근본 원인:  프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않음. 프레임을 잘 할당해야함.

프레임 할당

- 균등 할당 방식 (모든 프로세스에 균등하게 페이지 할당)
- 비례 할당 : 프로세스의 크기에 비례해 프레임을 나눠줌
- working set 모델 : 워킹셋의 크기만큼 프레임을 할당함
    - 워킹셋: 실행중인 프로세스가 일정 시간동안 참조한 페이지의 집합
    - 시간 간격과 참조한 페이지 목록이 있어야 워킹셋을 구성 가능.
- PFF(page fault frequency)
    - 페이지 폴트율이 높으면 적은 프레임을 갖고, 낮으면 많은 프레임을 갖는다는 아이디어
    - 상한선과 하한선을 기준으로 프레임을 더 할당해주거나 회수함
