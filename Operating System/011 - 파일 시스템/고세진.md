# 파일 시스템

### 파일

이름, 실행을 위한 정보나 읽기용 데이터, 메타데이터로 구성

### 메타데이터

파일 유형 (이걸 나타내기 위해서 주로 확장자를 이용)

크기 (현재 크기, 허용 가능한 최대 크기)

보호 (해당 파일에 어떤 사용자가 읽기 쓰기 실행 가능한지)

생성 날짜. 마지막 접근 날짜, 마지막 수정 날짜

생성자, 소유자

위치 (보조기억장치상의 위치)

### 파일 연산

파일을 다루는 모든 작업은 OS에 의해 이루어짐. 따라서 운영체제는 파일 연산을 위한 시스템콜을 제공한다.

: 생성, 삭제, 열기, 닫기, 읽기, 쓰기 

### 디렉터리

사용자 입장: 파일의 체계적 관리

파일 시스템 입장: 파일의 유일한 이름을 결정하는 방법 제공

경로: 디렉터리를 이용해 파일 위치, 나아가 파일 이름을 특정짓는 정보

### 디렉터리 엔트리

많은 OS는 디렉터리를 특별한 형태의 파일로 간주함. 

디렉터리는 내부에 해당 디렉터리에 담긴 대상과 관련된 정보를 담고 있고 이것은 보조기억장치에서 테이블 형태로 저장된다. 

테이블 내의 엔트리는 보통 (파일 이름, 위치 유추 정보 내지는 메타데이터)를 명시하다.

- 디렉터리 엔트리만 보아도 디렉터리에 무엇이 담겨있고 보조기억장치 어디에 있는지 직간접적으로 알 수 있음.
- 엔트리개수 = 디렉토리의 파일 개수(서브디렉토리 포함) + 부모 디렉토리(1) + 현재 디렉토리 (1)
- 현재 디렉토리, 부모 디렉토리, 차일드 디렉토리 , 현재 디렉토리 파일의 위치정보 내지는 메타데이터가 적혀있음.

<aside>
💡 파일 찾는 방법
루트 → 디렉터리 → 디렉터리 엔트리 뒤지기 
두번째 접근부터는 메타데이터를 메모리에 캐시

</aside>

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3095e9eb-cbca-4535-b019-0b4208807462/Untitled.png)

디렉토리 안에 엔트리들이 있고, 엔트리들이 파일의 데이터를 포인팅하는 구조이다. 

### 유닉스의 디렉토리 구조

파일 네임을 제외한 메타데이터를 inode라는 것으로 관리한다. 즉, 디렉토리 엔트리가 파일네임과 inode에 대한 포인터로 구성된다. 

- 엔트리가 가벼워지고 연속적으로 모아서 서치를 빠르게 할 수도 있음.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/38e7750e-ec42-409a-914e-2900559c2501/Untitled.png)

### 디렉토리 엔트리 구현

1. 파일네임 + 메타데이터를 리니어 리스트로 관리하는 방법
    - 간단하지만 서치성능 이슈
2. 해시테이블
    - 별도 해시테이블을 추가한다.
    - 파일 네임을 해시해서 특정 파일에 대한 포인터로 변환한다.
    - 서치 오버헤드를 줄일 수 있고 컬리전을 적절히 처리하자.

### 트리구조 디렉토리

- 서브디렉토리를 무한히 만들 수 있음
- 절대경로와 상대경로가 생김
- 디렉토리가 많아질수 있음 → search path??
- 디렉토리 삭제시 서브트리를 다 지울 것인가의 문제
    - 아래에 파일 없을때만 허용하거나 반대. 안전성과 편의성의 문제

### Acycle그래프 구조 디렉토리

공유를 위해 그래프 구조를 쓸 수도 있음

- 트래벌스 할 때 두번 찾아지는 문제
- 링크
    - 심볼릭 링크: 다른 디렉토리에서 한 파일에 대한 pathname만 갖는 경우. dangling reference 문제 발생. 다른 디렉토리를 통해서 삭제하는 경우! illegal path가 되어버림
    - 하드링크: 엔트리 카피가 생김.
        - 다른 디렉토리에서 파일을 지우더라도, 레퍼런스 카운트를 체크해서 0이 아닌 경우 실제로 지우지 않음.
        - 파일 수정시 일관성 문제를 OS가 해결해야함

### General 그래프 구조 디렉토리

- 사이클 허용 → 트래벌스가 안끝남

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/715c398e-0086-47d4-9660-34246a240456/Untitled.png)

- 사이클 있는경우 한 디렉토리 삭제시 접근 경로가 불가할 수 있음 (X 지우면..) 따라서 가비지 컬렉션으로 지워준다.

<aside>
💡 사이클 허용 → traverse, delete등에 오퍼레이션 복잡
사이클 불허 → 사이클 디텍션 오버헤드

</aside>

### protection

총 9개의 비트로 관리 RWX RWX RWX

각각 소유자, 소유자가 속한 그룹, 그외 권한을 표시

### Open 시스템 콜

메타데이터를 얻을 때 파일 시스템을 거치지 않기 위해서 메타데이터를 메모리에 올리는 작업

open file table이라는 자료구조에 저장하고, 인덱스로 file descriptor를 사용한다. 

파일 디스크립터를 통해 메타 데이터를 읽을 수 있고, 메타 데이터를 통해 디스크에 있는 내용을 바로 읽을 수 있게 함. 

### 파티셔닝과 포매팅

파티셔닝 : 저장 장치의 논리적 영역을 구획하는 작업 

포매팅: 파일 시스템을 설정해 어떤 방식으로 파일을 저장하고 관리할 것인지 결정, 새로운 데이터를 쓸 준비를 한다.

### 파일 할당 방법

하드디스크는 데이터를 덩어리 단위로 읽고 쓰는 블록 디바이스다. 2차 저장장치는 속도가 느리고 저장하는 양이 많기 때문에 한번에 많은 양을 읽고 쓴다. 

블록을 어떻게 할당할 것인가에 대한 방법론이다.

1. 연속 할당 방법
    - 장점: 연속된 블록을 파일에 할당할 수 있어서 첫 블록의 위치만 알면 나머지도 알게 되어 위치정보 저장이 구현이 간단하다.(첫 주소랑 길이만 알면 됨), io 오버헤드가 적음
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b483775-d898-48aa-9aed-bf3444fca299/Untitled.png)
    
    - 단점: 삭제할 때 외부 단편화 문제, 파일 크기 성장을 고려해서 블록을 더 할당해두는데 사용을 안하게 되는 내부 단편화 문제
    - file growth 문제가 없는 동영상 서버등에 사용, 시간이 중요한 time critical application이나 리얼타임 시스템에서 사용
    
2. 불연속 할당 -  연결 할당 방법 
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eb63fcba-51e2-4bf5-8dd8-53bf8dbc778a/Untitled.png)
    
    장점: 공간 낭비가 없고, 블록 시작 위치와 길이만 알면 된다
    
    단점: 
    
    1. 랜덤 액세스 성능이 안좋음 (n번 블록 바로보기 불가능), 
    2. 블록 읽을때마다 seek 해야함
    3. 포인터 하나가 유실되면 이후 블록을 전부 유실
    
    → 이걸 개선해서 FAT 파일시스템
    

1. 불연속 할당 - 색인 할당

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ee3c389-afe6-4c1e-b5b0-f6874c305be2/Untitled.png)

인덱스 블록을 사용하고, 그 안에 파일의 블록 주소를 모아 관리함

장점: 액세스 속도가 향상된다. 

단점: 인덱스 블록도 블록이라서, 저장할 수 있는 블록 주소가 제한된다. 

- 링크드 리스트로 인덱스 블록 확장
    - 데이터 유실 가능
- 2레벨 인덱스 블록으로 인덱스 블록 확장
    - 1레벨 인덱스 블록의 공간을 2레벨 인덱스 블록의 포인터로 사용
    - 여전히 파일 크기의 제한이 있음

### FAT (file access table)

연결 할당 방법에서 연결 정보를 별도 테이블로 구현하여 하드디스크 파티션에 따로 저장한다. 실행시 테이블이 메모리에 캐시되어서 빠르게 동작 가능

단점: fat 자체가 유실되면 문제 → 카피를 3개 만들고, 하나라도 유실되면 나머지로 복구한다. 단, 파일 위치 변동시 3개에 다 반영해야하는 문제가 있는데 어차피 메모리에서 편집하고 나중에 한번에 디스크에 적으니까 오버헤드가 엄청 크지 않다고 함.

### 유닉스 파일 시스템

inode에 메타데이터와 파일 위치정보를 저장함.

inode에서 직접 저장할 수 있는 블록 개수에 제한이 있기 때문에, 블록들을 간접적으로 가리키는 single, double ,triple indirect 블록을 둔다.
