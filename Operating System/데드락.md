# 데드락 (교착 상태)

> 둘 이상의 프로세스(혹은 스레드)가 공유된 자원을 서로 기다려 무한 대기에 빠지는 상황

![Untitled](https://user-images.githubusercontent.com/70252417/202484712-962b90f4-af71-4596-aad2-081c0e7a8b8a.png)
![Untitled 1](https://user-images.githubusercontent.com/70252417/202484435-d6a4562b-986d-4219-b50c-05ed3c5bc63e.png)

멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황에서 발생한다. **다른 블락된 프로세스에 의해 발생하는 이벤트를 대기**하고 **실행(running) 상태로 변경할 수 없는 경우** `데드락(교착 상태)`이라고 한다.

## 데드락이 일어나는 조건

1. ******************상호 배제 (Mutual Exclusion)******************
    
    한 번에 하나의 프로세스에만 해당 자원이 할당될 수 있다.
    
2. **점유 대기 (Hold and Wait)**
    
    최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가적으로 점유하기 위해 대기하는 프로세스가 존재해야 한다.
    
3. **비선점 (No preemption)**
    
    다른 프로세스가 할당중인 자원(이미 할당된 자원)을 뺏을 수 없다.
    
4. **순환 대기 (Circular Wait)**
    
    프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.
    

## 데드락 해결 방법

1. **데드락이 발생하지 않도록 예방하기 (Deadlock Prevention)**
    
    데드락이 일어나는 조건 중 하나라도 발생하지 않도록 한다.
    
    1) 상호 배제 조건 방지
    
    여러 프로세스가 자원을 공유하도록 한다.
    
    2) 점유 대기 조건 방지
    
    프로세스가 실행 전 필요한 자원 한 번에 요청한다.
    
    3) 비선점 조건 방지
    
    높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
    
    4) 순환 대기 조건 방지
    
    자원을 순환 형태로 대기 하지 않도록 한다.
    
    이렇게 조건 중 하나를 사전에 방지하여 예방하는 방식은 **시스템의 처리량이나 효율성을 떨어 뜨리는 단점**이 있다.
    
2. **데드락 회피하기 (Deadlock Avoidance)**
    
    데드락이 발생 가능한 상황(불안정 상태)이면 리소스를 할당하지 않는다. 
    
    - 안정 상태 (Safe State)
        
        데드락이 발생하지 않도록 모든 프로세스에 자원을 할당하는 경로가 존재하는 상태
        
    - 불안정 상태 (Unsafe State)
        
        데드락 발생 가능성이 있는 상태 (데드락을 의미하는 것이 아니고 가능성이 있는 상태)
        
    
    ### 은행원 알고리즘
    
    ![Untitled 2](https://user-images.githubusercontent.com/70252417/202484478-17e59e7d-36ab-4107-aee7-7e3d16d6b79a.png)
    
    미리 결정된 모든 자원들의 최대 할당량을 가지고 시뮬레이션 해서 안정 상태에 들 수 있는지 판별한다. Need의 값은 Maximum에서 Allocated 값을 뺀 것이다.
    
    P1부터 P4 순으로 프로세스가 자원이 할당 가능한지 체크한다 가정하면 P1은 필요량이 현재 가능한 할당량 보다 많기 때문에 할당이 불가능하다. P2는 할당이 가능하다. 마찬가지로 P4도 할당이 가능하다. P2와 P4가 수행이 끝난 후 자원을 반환하게 되면 P1은 자원이 할당 가능하다. 이 후 P1이 자원을 반환하면 P3도 할당이 가능하므로 P2 → P4 → P1 → P3인 경로가 존재하므로 안정 상태이다.
    
    이 알고리즘은 **각각의 프로세스가 최대 자원 요구량의 상황까지 고려하며 교착 상태를 피하기 위한 알고리즘**이다. 그러나 미리 자원의 최대 요구량도 알아야 하고 할당할 수 있는 자원의 수가 일정해야 한다는 등 제약 조건이 많다. 또한 시스템 과부하가 증가하기도 한다.
    
3. **데드락 탐지 및 회복 (Deadlock Detection)**
    
    데드락이 되도록 허용하고 발생 시 회복하는 방법이다. 주기적으로 교착상태 발생 여부를 파악한다.
    
    - 탐지 기법
        
        자원 할당 그래프를 이용하여 교착 상태를 탐지한다.
        
    - 회복 기법
        
        교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원 해제시켜 회복하는 방법
        
        - 프로세스  종료
            
            교착 상태에 빠진 모든 프로세스를 종료하거나 하나씩 종료하면서 데드락을 탐지하며 회복시키는 방법이 있다.
            
        - 할당된 자원 해제 (자원 선점하기)
            
            프로세스에 할당된 자원을 선점해서 교착 상태를 해결할 때 까지 다른 프로세스에 할당하는 방법
            

## 식사하는 철학자 문제

![Untitled 3](https://user-images.githubusercontent.com/70252417/202484927-7a500db0-2d50-4e8d-97ec-7ac17bff8c70.png)

> 1. 일정 시간 생각을 한다.
> 
> 
> 2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
> 
> 3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
> 
> 4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
> 
> 5. 오른쪽 포크를 내려놓는다.
> 
> 6. 왼쪽 포크를 내려놓는다.
> 
> 7. 다시 1번으로 돌아간다.
> 

모든 철학자가 동시에 자신의 왼쪽 포크를 집는다면, 오른쪽 포크가 가능해 질 때 까지 모든 철학자가 기다려야 한다. 하지만 모든 철학자가 서로 기다리고 있기만 하고 3번에서 대기 하고 있기 때문에 교착 상태가 발생하였다.

### 해결 방법

**모니터**를 사용하여 양쪽 포크를 얻을 수 있을 때 포크를 집도록 강제한다. 각각의 철학자에게 상태 값이 존재하고 양 옆의 철학자가 식사를 하지 않는 상황, **즉 양쪽 포크를 둘 다 집을 수 있는 상황**에 포크를 집어 식사를 한다.

![Untitled 4](https://user-images.githubusercontent.com/70252417/202485042-5872b276-374a-4b56-a684-c705671d09b2.png)


식사를 하기전 pickup을 호출 하여 상태를 변경 후 연산이 성공적으로 작동 하면 식사를 한다. 마친 경우에는 putdown을 호출한다.
