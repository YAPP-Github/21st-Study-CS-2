### 메인 메모리

메인 메모리는 CPU가 직접 접근할 수 있는 기억 장치로 프로세스가 실행되려면 실행에 필요한 프로그램이 메모리에 올라와야 한다. 

CPU는 레지스터의 지시에 따라 메모리에 접근하여 다음 수행할 명령어 즉 Program Counter에 대응하는 연산을 fetch한다. 명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 가져와야 하는데 이때 MMU가 필요하다.

### MMU, memory management unit

MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다.

메모리 공간이 한정적이기에 가상 주소를 사용한다. 가상 주소에서 실제 데이터가 담긴 곳에 접근하려면 빠른 주소 변환이 필요하고 이를 MMU가 한다.

- `base 레지스터 값 + 논리적 주소`를 합하여 물리적 주소를 찾는다.
- 한 프로세스는 독립된 메모리 공간을 가지며 다른 공간을 침범하면 안된다. 한 프로세스에 할당 된 공간은 `base` ~ `base + limit` 이다. `limit 레지스터`를 두어 프로세스 영역 밖은 접근하지 못하도록 한다.
- 프로세스 A와 B는 같은 논리 주소를 가질 수 있다. 물리적 주소는 달라야 하므로 Context Switching이 발생할 때마다 `relocation 레지스터`의 값을 해당 프로세스의 값으로 재설정한다.
<img width="716" alt="image" src="https://user-images.githubusercontent.com/67777523/209145943-6d965473-f046-4a23-bb15-5ecf4bd4b867.png">

### 메모리 과할당과 페이지 교체

페이징 같은 메모리 관리 기법은 가상 메모리를 사용해서 사용자가 눈치 채지 못한채로 마치 큰 메모리를 할당해주듯이 동작한다. 과할당 상황에 대해서 사용자를 속인 것을 들킬만한 상황이 존재한다.

프로세스 실행 도중 페이지 폴트가 발생하는 경우 필요한 페이지를 디스크에서 찾아서 메모리의 빈 프레임에 올려야 하는데 모든 메모리가 사용 중이라 빈 프레임이 없을 수 있다. 이러한 과할당을 해결하기 위해서는 빈 프레임을 확보할 수 있어야 한다.

빈 프레인을 확보하는 방법은 다음과 같다.

- 메모리에 올라와있는 프로세스를 종료시켜 빈 프레임을 확보한다.
- 프로세스 하나를 swap out하여 빈 프레임을 확보한다.

swapping 기법으로 공간을 바꿔치기하는 두 번째 방법과 달리, 첫 번째 방법은 페이징 시스템을 사용자에게 들킬 가능성이 높다. 그래서 페이지 교체는 두 번째 방법인 swap out하는 방식으로 동작한다.

사용자가 눈치 채지 못하도록 페이지 교체가 이루어지기 위해서는 페이지 교체 오베헤드를 줄여야 한다.

**오버헤드 감소시키기**

victim 프레임 비울 때, 원하는 페이지를 프레임에 올릴 때 총 두 번의 디스크 접근이 필요하다. 페이지 교체가 많이 발생하면 입출력 연산이 많아서 오버헤드가 증가한다. 오버헤드를 줄이는 방법은 다음과 같다.

1. 디스크 접근 횟수를 줄인다.
    
    모든 페이지에 변경 비트를 두어 victim 페이지가 선택되면 해당 페이지의 비트를 확인한다.
    
    비트가 set 상태라면, 해당 페이지가 메모리에 올라온 뒤 수정이 발생해 디스크 상의 페이지 내용과 달라졌다는 것을 의미한다.
    
    비트가 clear 상태라면, 메모리 상의 페이지와 디스크에 있는 내용이 동일하다는 것을 의미한다.
    
    비트의 상태를 확인해 불필요한 디스크 기록을 줄여 오버헤드를 감소시킨다.
    
2. 페이지 교체 알고리즘을 사용한다.
    
    상황에 따라 페이지 폴트 발생을 최대한 줄일 수 있는 페이지 교체 알고리즘을 사용한다.
    

### 캐시 메모리

메인 메모리에 저장된 내용의 일부를 임시로 저장해두어 기억장치 CPU와 메인 메모리의 속도 차이로 발생하는 성능 저하를 방지한다. CPU가 어떤 데이터에 재접근할 때, 캐시에 저장된 데이터를 활용해서 메모리 참조 및 인출 과정에 대한 비용을 줄인다. 

1. CPU에서 주소 전달, 캐시 기억장치에 명령이 존재하는지 확인
2. Hit(존재) → 명령어를 CPU로 전달
3. Miss(존재X) → 주기억장치로 접근 → 해당 명령어를 가진 데이터 인출 → 명령어 데이터를 캐시에 저장 → 명령어를 CPU로 전달

**지역성의 원리**

CPU가 어떤 데이터를 원할지 예측하여 적중률을 높이는 것이 중요하다. 이를 위해 사용되는 것이 지역성의 원리.

- 시간 지역성
    
    최근에 참조된 주소가 다시 참조되는 특성
    
- 공간 지역성
    
    참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성
    

**캐싱 라인**

캐시를 사용할 때 주소에 해당되는 데이터를 찾기 위해 전부 순회하는 것은 비효율적이다. 그래서 캐시에 데이터를 저장할 때, map 같은 자료구조를 활용해 메모리 주소를 함께 저장해 빠르게 원하는 정보를 찾을 수 있도록 한다.
