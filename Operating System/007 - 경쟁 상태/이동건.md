# 경쟁 상태와 세마포어 및 뮤텍스

# 경쟁 상태(Race Condition)

> **경쟁상태(Race Condition)**란 공유 자원에 두 개 이상의 프로세스가 접근할 때, 결과값에 영향을 줄 수 있는 상태를 말한다.
> 

경쟁 상태의 프로세스인 경우 세 가지 문제에 직면한다.

### Mutual Exclusion

경쟁 상태를 막기 위해 한 프로세스가 공유 자원에 접근하고 있으면 **그 자원을 사용하지 못하도록 막거나**, 다른 프로세스가 그 자원을 사용하지 못하도록 한다. 이것을 **상호 배제(Mutual Exclusion)**이라 한다.

### Deadlock

위와 같이 상호 배제를 수행할 경우 추가적인 제어 문제가 발생할 수 있는데, 이는 교착상태(Deadlock)이다. 프로세스가 각자 프로그램을 실행하기 위해 두 자원 모두에 엑세스 해야 한다고 가정할 때 프로세스는 두 자원 모두를 필요로 하므로 **필요한 두 리소스를 사용하여 프로그램을 수행할 때까지 이미 소유한 리소스를 해제하지 않는다.** 이러한 상황에서 두 프로세스는 **교착 상태**에 빠지게 되는 문제가 발생한다.

### Starvation

프로세스들이 더 이상 진행하지 못하고 영구적으로 블록되어 있는 상태이며 시스템 자원에 대한 경쟁 도중에 발생할 수 있고 프로세스 간의 통신 과정에도 발생할 수 있는 문제이다. 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태가 되게 된다.

## 경쟁 상태가 발생하는 경우

1. **커널 작업을 수행하는 중에 인터럽트 발생**
    
    커널모드에서 데이터를 로드하여 작업을 하던 도중 인터럽트가 발생하여 같은 데이터를 조작하는 경우에 발생할 수 있다. **커널이 가진 전역변수는 모든 프로세스의 공유 자원**이므로 경쟁상태의 가능성이 있다.
    
    ⇒ 커널모드에서 작업을 수행하는 동안 인터럽트를 disable시켜 인터럽트가 CPU제어권을 가져가지 못하도록 하여 해결할 수 있다.
    
2. **프로세스가 시스템 콜을 하여 커널모드로 진입해서 작업을 수행하는 도중에 문맥 교환이 발생할 경우**
    
    프로세스1이 커널모드에서 데이터를 조작하던 도중 시간이 초과되어 CPU제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우를 말한다.
    
    ⇒ 프로세스가 커널모드에서 작업을 하는 경우에는 시간이 초과되더라도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 한다.
    
3. **멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근할 경우**
    
    멀티프로세스 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우에 발생할 수 있다.
    
    ⇒ 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대해 lock/unlock함으로써 해결할 수 있다.
    

## 세마포어 (Semaphore)

> 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 **여러 Process 혹은 Thread**가 접근하는 것을 막아준다. 즉, 동기화 대상이 **하나 이상**이다.
> 

![Untitled](https://user-images.githubusercontent.com/70252417/206466021-0e8cc144-ecfb-4b95-96df-0bef3c67d285.png)



### **세마포어 P, V 연산**

- P : 임계 구역 들어가기 전에 수행 ( 프로세스 진입 여부를 자원의 개수(S)를 통해 결정)
- V : 임계 구역에서 나올 때 수행 ( 자원 반납 알림, 대기 중인 프로세스를 깨우는 신호 )

```c
procedure P(S)   --> 최초 S값은 1임
    while S=0 do wait  --> S가 0면 1이 될때까지 기다려야 함
    S := S-1   --> S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함
end P

--- 임계 구역 ---

procedure V(S) --> 현재상태는 S가 0임
    S := S+1   --> S를 1로 원위치시켜 해제하는 과정
end V
```

이를 통해, 한 프로세스가 P 혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다. P와 V를 사용하여 임계 구역에 대한 상호배제 구현이 가능하게 되었다.

## 뮤텍스 (Mutex)

> 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 **하나의Process 혹은 Thread**
가 접근하는 것을 막아준다. 즉, 동기화 대상이 **하나**이다.
> 

![Untitled 1](https://user-images.githubusercontent.com/70252417/206465664-31d97388-1b84-4d0b-8516-532f45d5213f.png)


해당 접근을 조율하기 위해 lock과 unlock을 사용한다.

- lock : 현재 임계 구역에 들어갈 권한을 얻어옴 ( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기 )
- unlock : 현재 임계 구역을 모두 사용했음을 알림. ( 대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음 )

뮤텍스는 상태가 0, 1로 **이진 세마포어**로 부르기도 함

1. **데커(Dekker) 알고리즘**
    
    flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식
    
    - flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
    - turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수
    
    ```c
    while(true) {
        flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
        while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
            if(turn == j) { // j가 임계 구역 사용 중이면
                flag[i] = false; // 프로세스 i 진입 취소
                while(turn == j); // turn이 j에서 변경될 때까지 대기
                flag[i] = true; // j turn이 끝나면 다시 진입 시도
            }
        }
    }
    
    // ------- 임계 구역 ---------
    
    turn = j; // 임계 구역 사용 끝나면 turn을 넘김
    flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
    ```
    
2. **피터슨(Peterson) 알고리즘**
    
    데커와 유사하지만, 상대방 프로세스 혹은 스레드에게 진입 기회를 양보하는 것에 차이가 있다.
    
    ```c
    while(true) {
        flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
        turn = j; // 다른 프로세스에게 진입 기회 양보
        while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
        }
    }
    
    // ------- 임계 구역 ---------
    
    flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
    ```
    
3. **제과점(Bakery) 알고리즘**
    
    여러 프로세스 혹은 스레드에 대한 처리가 가능한 알고리즘. 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.
    
    ```c
    while(true) {
        
        isReady[i] = true; // 번호표 받을 준비
        number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
        isReady[i] = false; // 번호표 수령 완료
        
        for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
            while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
            while(number[j] && number[j] < number[i] && j < i);
            
            // 프로세스 j가 번호표 가지고 있어야 함
            // 프로세스 j의 번호표 < 프로세스 i의 번호표
        }
    }
    
    // ------- 임계 구역 ---------
    
    number[i] = 0; // 임계 구역 사용 종료
    ```
