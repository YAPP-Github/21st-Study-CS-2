# IPC 통신

> IPC(Inter Process Communication)이란 **프로세스들 사이**에서 **서로 데이터를 주고 받는** 행위 또는 그에 대한 방법이나 경로를 뜻한다. 즉 프로세스들 간에 의사소통을 하는 것이다.
> 

## 배경
![Untitled](https://user-images.githubusercontent.com/70252417/205057165-4daa6146-7435-41fd-af6a-2d2c538cd9d4.png)


프로세스는 서로 독립적으로 실행된다. 서로 다른 프로세스에게 영향을 받지 않는다는 것을 의미한다. (스레드는 한 프로세스 안에서 자원을 공유하므로 영향을 받는다.) 하지만 서로 다른 프로세스도 데이터를 주고 받아야 할 상황이 생긴다. 이를 위해서 커널 영역에서 **IPC 라는 내부 프로세스간 통신**을 제공하며 프로세스는 커널이 제공하는 IPC 설비를 이용해서 프로세스 간 통신을 가능하게 한다.

## IPC 종류

### 1.  익명 파이프

![Untitled 1](https://user-images.githubusercontent.com/70252417/205057214-4d16fcc1-6729-429c-993a-d38aace98900.png)


일반적인 파이프이며 **통신할 프로세스가 명확하게 알 수 있는 경우**에 사용한다. 이는 **부모-자식** 혹은 **형제 프로세스간 통신**에 사용하며 외부 프로세스에서는 사용할 수 없다. 파이프는 두 프로세스를 연결하며 **하나의 프로세스는 데이터를 쓰기만**, 다른 하나는 **데이터를 읽기만** 할 수 있다. 이런 특성 때문에 반이중(Half-Duplex) 통신 이라고도 한다.

간단하게 사용할 수 있다는 장점이 있지만 송수신을 모두 가능하게 하려면 **write용 파이프 하나, read용 파이프 하나를 따로 만들어야 한다. read와 write가 기본적으로 block 모드로 작동하기 때문에,** 프로세스가 read가 대기중이면 read가 끝나기 전까지는 write를 할 수 없어 효율적이지 못하다.

### 2. 네임드 파이프

![Untitled 2](https://user-images.githubusercontent.com/70252417/205057260-eec0aeab-3094-48b1-97fd-1c1080cbaba6.png)


네임드 파이프는 익명 파이프와 다르게 **전혀 모르는 상태의 프로세스들 사이의 통신**에 사용한다. **파이프의 이름만 알면 통신이 가능하며** 부모나 형제간 프로세스가 아니어도 통신을 가능하게 한다.

전혀 다른 프로세스들 사이에서도 통신이 가능한데 이는 프로세스 통신을 위해 **FIFO 라 불리는 특수 파일을 이용하기 때문**이다.

```c
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>

int main()
{
    int state;
    state = mkfifo("/tmp/myfifo", S_IRUSR|S_IWUSR);
    if (state < 0)
    {
        perror("mkfifo error \n");
        exit(0);
    }
    for(;;)
    {
        sleep(1);
    }
}
```

네임드 파이프의 생성은 `mkfifo`를 통해 이루어지는데, `mkfifo` 가 성공하면 지정한 이름으로 파일이 생성된다.

익명 파이프와 마찬가지로 양방향 통신을 위해서는 Write용 파이프, Read 용 파이프를 따로 만들어야 하며 read와 write도 기본적으로 block 모드로 작동하기 때문에 read가 끝나기 전까지는 write를 할 수 없다.

### 3. 메시지 큐

![Untitled 3](https://user-images.githubusercontent.com/70252417/205057299-242e61ac-3134-441f-902b-1a0d31f9d16f.png)

파이프가 아니며 컨베이너 벨트와 유사한 구조이다. 컨베이너 벨트에 라벨을 붙이면 동시에 여러 물건이 와도 쉽게 관리 할 수 있는 것 처럼 큐에 쓸 **데이터에 번호를 붙임으로 써** 여러개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.

입출력 방식은 네임드 파이프와 동일하지만, **커널에서 관리**하며 데이터의 흐름이 아닌 **메모리 공간**이다.

### +) 메시지 큐를 사용하기 위한 시스템 콜

- msgget : 메시지 큐 생성
    
    ```c
    int msgget ( key_t key, int msgflg )
    ```
    
- msgsnd : 메시지 큐로 데이터를 전송
    
    ```c
    int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
    ```
    
- msgrcv : 메시지 큐에서 데이터 수신
    
    ```c
    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
    ```
    

### 4.  공유 메모리

![Untitled 4](https://user-images.githubusercontent.com/70252417/205057349-b4ec0d58-249d-4f5b-ae66-ec0742dfb70d.png)

파이프와 메시지 큐는 통신을 위한 설비이지만 **공유 메모리는 데이터 자체를 공유하도록 지원하는 설비**이다. 프로세스는 독립적인 특성이 있어 자신만의 메모리 영역을 가지고 있고 다른 프로세스가 접근하여 함부로 데이터를 읽거나 쓰지 못하도록 커널에 의해서 보호되지만 메모리 영역에 있는 데이터를 다른 프로세스도 사용할 수 있도록도 해야한다.

프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당 해주며 이후 **모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다. 중개자 없이 곧바로 메모리에 접근**할 수 있기 때문에 **다른 모든 IPC들 중에서 가장 빠르게 작동**할 수 있다. 예를 들어 메시지 큐의 경우 프로세스 A가 메시지 큐에 데이터를 쓰고 프로세스 B는 다시 메시지 큐에서 데이터를 가져온다. 하지만 공유 메모리는 메모리 자체를 공유하기 때문에 불필요한 데이터 복사로 인한 오버헤드가 발생하지 않는다. 또한 **단순히 공유 메모리를 포인트 함**으로써 프로세스에 사용되는 메모리는 증가하지 않는다. 프로세스간의 Read, Write를 모두 필요로 할 때 사용된다.

```c
shm_id = shmget((key_t)KEY_NUM, MEM_SIZE, IPC_CREAT | 0666);

shm_addr = shmat(shm_id, (void*)0, 0);
```

### 5.  메모리 맵

![Untitled 5](https://user-images.githubusercontent.com/70252417/205057386-0b118e78-26dd-4938-9be9-990e4d23bc32.png)

운영체제에서 파일을 다루는 방법 중 하나로써 메모리 맵도 공유 메모리와 마찬가지로 메모리를 공유한다. 하지만 메모리 맵의 경우는 **열린 파일을 메모리에 맵핑**시켜서 공유한다는 점이 다르다. 즉 공유 매개체가 파일 +  메모리 이다.

프로세스의 **가상 메모리 주소 공간에 파일을 매핑한 뒤** 가상 메모리 주소에 직접 접근 하는 것으로 파일 읽기와 쓰기를 대신한다. 파일로 대용량 데이터를 공유할 때 사용된다.

### 6. 소켓

![Untitled 6](https://user-images.githubusercontent.com/70252417/205057417-fac590d1-82e3-4838-973d-37cc0fc9f469.png)


**동일한 호스트 운영 체제에서 실행되는 프로세스 간** 데이터를 교환하기 위한 데이터 통신 엔드포인트이다. 데이터 교환을 위해 양쪽 PC에서 임의의 포트를 각각 정하고 해당 포트 간의 통신을 통해 데이터를 주고 받는 방식이다. 이때 **각각 PC의 포트를 담당하는 소켓이 각각 하나의 프로세스**이다. 타 PC의 포트를 연결하려 하면 두 프로세스는 서로 확인 과정을 걸쳐 연결을 진행하고 마치 파이프와 같이 1대 1로 데이터를 주고 받는 방식이다.

클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다. 또한 양방향 통신이 가능하다.

## 정리

| IPC 종류 | 익명 파이프 | 네임드 파이프 | 메시지 큐 | 공유 메모리 | 메모리 맵 | 소켓 |
| --- | --- | --- | --- | --- | --- | --- |
| 사용 시기 | 부모 자식 간 단방향 통신시 | 다른 프로세스와 단방향 통신시 | 다른 프로세스와 단방향 통신시 | 다른 프로세스와 양방향 통신시 | 다른 프로세스와 양방향 통신시 | 다른 프로세스와 양방향 통신시 |
| 공유 매개체 | 파일 | 파일 | 메모리 | 메모리 | 파일 + 메모리 | 소켓 |
| 통신 단위 | 스트림 | 스트림 | 구조체 | 구조체 | 페이지 | 스트림 |
| 통신 방향 | 단방향 | 단방향 | 단방향 | 양방향 | 양방향 | 양방향 |
| 통신 가능 범위 | 동일 시스템 | 동일 시스템 | 동일 시스템 | 동일 시스템 | 동일 시스템 | 동일 + 외부 시스템 |

이러한 IPC 통신에서 **프로세스 간 데이터를 동기화하고 보호**하기 위해 **세마포어**와 **뮤텍스**를 사용한다.
