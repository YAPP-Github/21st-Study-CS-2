- CPU 스케줄링 알고리즘?
    - 어떤 프로세스를 먼저 처리할 것인가에 대한 방법론
    - ‘실행’ = 메모리에 프로그램 일부 올라가있고 CPU에 의해 그 명령어들이 수행되고 있다
        - 실행중인 프로그램 = 프로세스
    - 기본적으로 cpu 1개로 가정
        - 여러 프로그램이 동시에 실행되고 있는 상황 → 다수의 프로세스
        - ‘동시에’ ? → 시분할
    
- CPU 스케줄러
    - CPU가 유휴 상태가 될 때마다, 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야 한다. 선택 절차는 CPU 스케줄러(CPU Scheduler)에 의해 수행된다.
    - CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.
    - Ready Queue는 반드시 FIFO 방식의 큐가 아니어도 되고, 우선순위 큐, 트리 등으로 구현될 수 있다. 일반적으로 큐에 있는 레코드들은 프로세스의 프로세스 제어 블록(PCB)들 이다.
    
- CPU 스케줄링 발생하는 상황
    - 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (I/O 발생)
    - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 (인터럽트 발생)
    - 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 (I/O 종료)
    - 프로세스가 종료할 때
    

---

- 비선점형
    - FCFS
    - SJF
    - 우선순위
- 선점형
    - 라운드로빈
    - SRF
    - 다단계 큐

---

## 1️⃣ 비선점형 ( FCFS, SJF, 우선순위 )

- 비선점형 방식은 프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않는다
- 따라서 컨텍스트 스위칭으로 인한 부하가 적다

### < FCFS >

- First Come, First Served
- 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘
- 길게 수행되는 프로세스로 인해 ‘레디큐에서 오래 기다리는 현상 (convoy effect)이 발생하는 단점 존재


### < SJF >

- Shortest Job First
- 실행시간이 가장 짧은 프로세스를 먼저 실행
- 긴 시간을 가진 프로세스가 실행되지 않는 현상 (starvation) 이 일어난다
- 평균 대기 시간이 가장 짧다!
- 실제로는 실행 시간을 알 수 없어 과거에 실행했던 시간을 토대로 추측해서 사용한다

### < 우선순위 >

- 기존 SJF의 경우 starvation 이 존재했다
- 이는 오래된 작업일수록 ‘우선순위 높이는 방법 (aging)’ 을 통해 단점을 보완 = 우선순위
- SJF와 많이 사용된다
- SJF를 기반으로 하는 것 뿐만 아니라 FCFS 와도 접목해서 적용 가능, 또한 선점형/비선점형 모두 우선순위 스케줄링 사용 가능

### < convoy effect  VS  starvation >

- convoy effect는 몇개의 시간이 오래 걸리는 프로세스로 인해 전체 OS가 느려지는 FCFS(First Come First Serve) 알고리즘과 관련된 현상
- 예를 들어 P1이 100, P2와 P3가 5정도의 시간이 필요한 경우 P2가 실행되기 전 적어도 100의 시간을 기다려야 하는 것을 의미
- starvation(기아)는 프로세스가 “무기한으로” 대기할 때 발생한다. 우선순위가 자꾸 밀려져서 해당 프로세스가 아예 실행이 안되는 것이다. 이를 극복하는 한 가지 방법은 aging을 통해 우선순위를 높이는 방법이다.
    
    실행되지 않은 프로세스라면 우선순위를 높여서 실행되게 만드는 것
    
    = 오래되면 오래될 수록 우선순위 높인다
    

---

## 2️⃣ 선점형 ( 라운드로빈, SRF, 다단계큐 )

- 선점형 방식은 현대 운영체제가 사용하는 방식으로, 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식!!!
    - 비선점은 컨텍스트 스위칭으로 인한 부하적다
    - 그럼 선점형의 장점은..?
        - 응답이 빠르다
        - 우선순위가 높은 프로세를 먼저 수행할 때 유리하다

### < 라운드로빈 >

- 현대 컴퓨터가 쓰는 스케줄링방법이며 단순한 선점형 알고리즘
- 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐(ready queue)의 뒤로 가는 알고리즘

- 예를 들어 q만큼의 할당 시간이 부여되었고 N개의 프로세스가 운영된다고 하면 (N - 1)* q 시간이 지나면 자기 차례가 오게 된다.
- 할당 시간이 너무 크면 FCFS가 되고 , 너무 짧으면 컨텍스트 스위칭이 잦아져서 오버헤드, 즉 비용이 커진다.
    - 할당 시간이 너무 길면 A 다하고, B 다음에 또 다하고 .. 이런 식으로 갈 수 있음
- 일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아진다는 특징이 있다.
- 또한, 이 알고리즘은 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰인다.


### < SRF >

- SJF는 중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 그다음 짧은 작업을 이어나가는데,
- SRF → SJF 처럼 짧은거부터 하다가 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘
- SRF = SJF + 강제

### < 다단계 큐 >

- 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용한 것
- 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징
- 우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리가 안되는 기아현상(starvation)이 발생할 수도 있다.
- 참고로 비선점형 다단계 큐 스케줄링 알고리즘도 존재
- 우선순위가 높은 큐 다하고 그다음 큐를 실행
- 우선순위가 낮은 큐에 있는 애들이 실행이 안되는 starvation 이 발생할 수도 있다
    - 무한 대기!
