### 이중 동작 모드(Dual-Mode Operation)

![image](https://user-images.githubusercontent.com/85336456/203785348-bb136773-b813-415f-ab6d-a4bc92fb231f.png)

- **이중 동작 모드**란 운영체제가 두 개의 독립된 동작 모드로 동작하는 것을 의미한다.
    - 이 두 개의 독립된 동작 모드는 **유저 모드**와 **커널 모드**를 의미한다.
    - 하드웨어에 **모드 비트(Mode bit)** 가 있는데, 0이면 커널 모드, 1이면 사용자 모드를 의미한다.

- 최초 부팅 시 하드웨어는 커널 모드에서 시작하며, 운영체제가 올라온 후부터 사용자 모드가 시작된다.
    - **인터럽트** 또는 트랩이 발생할 때마다 하드웨어는 모드 비트를 0으로 바꾸고 커널 모드로 전환한다.

- **커널 모드**는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드로서, 이 모드에서는 **모든 종류의 명령을 모두 실행할 수 있다.**

- 해킹 혹은 초보 사용자의 실수로 잘못된 프로그램을 실행하여 **시스템을 망가뜨리는 위험을 방지**하기 위해 두 모드를 나누어 놓은 것이다.
    - 만약 유저 모드에서 시스템 콜을 호출할 경우 운영체제에서 불법적 접근이라 여겨 트랩을 발생시킨다.

### 시스템 콜(System Call)

- 우리가 일반적으로 사용하는 프로그램은 **응용프로그램, 즉 유저 레벨의 프로그램**이다.
    - 응용프로그램을 사용할 때 우리가 흔히 사용하던 기초적인 기능들, 예를 들어 파일을 읽어 들인다던지, 파일을 쓴다던지, 화면에 메시지를 출력하는 모든 기능들이 커널 모드를 사용한다.

- 그렇다면 **응용프로그램에서 커널 모드의 명령어를 어떻게 실행하는 것**일까?
    - 여기서 **시스템 콜**이라는 키워드가 등장한다.

- **시스템 콜**은 운영체제에서 응용프로그램에게 제공하는 인터페이스이다.
    - 커널 영역의 기능을 사용자 모드에서 사용 가능하도록, 즉 **프로세스가 하드웨어에 직접 접근해 필요한 기능을 사용할 수 있게 해주는 것**이 **시스템 콜**이다.
    - **응용프로그램은 시스템 콜을 사용하여 커널에 요청을 보낼 수 있다.**

- **파일 복사 상황**을 예로 들어보자.

```c
cp in.txt out.txt
```

![image](https://user-images.githubusercontent.com/85336456/203785379-1d9fe139-5ef9-47d4-ade3-90ac44ea4c75.png)

- 프로그래머 입장에서는 **단 한 줄로 파일 복사 명령**을 내릴 수 있다.
- 그러나, **내부적으로는** 원본 파일을 복사해 새로운 파일을 생성하고, 그 파일 내부에 텍스트를 붙여넣는 등, **여러 시스템 콜이 호출된다.**

### 시스템 콜의 세부 동작

![image](https://user-images.githubusercontent.com/85336456/203785412-fdd4b61e-fc8d-424a-96c7-d9ebec2740f2.png)

1. 사용자가 프로세스에서 시스템 콜을 요청하면 **커널 모드로 전환**된다.
2. 커널은 요청받은 시스템 콜에 대응하는 번호를 확인한다.
3. 커널은 해당 번호에 알맞는 인터럽트 서비스 루틴을 호출한다.
4. 인터럽트 서비스 루틴을 모두 처리하면, 커널 모드에서 사용자 모드로 전환된다.

> **커널은 각 시스템 콜을 구분하기 위해 고유 번호를 할당하고, 그 번호에 해당하는 루틴을 커널 내부에 정의한다.**
> 

### API

- 기본적으로 **시스템 콜**은 **운영체제가 직접 제공**하고 있는 프로그래밍 인터페이스이다.
    - 직접 운영체제가 제공하다보니, 복잡한 기능보다는 **기본적 기능만을 제공**한다.
        - 운영체제는 코드 사이즈도 적어야 하고, 매우 빠른 속도로 실행할 수 있어야 하기 때문이다.
    
- **`printf`** 를 예로 들어보자.
    - 똑같은 변수 데이터를 화면에 출력하는데 어떤 경우엔 `int` 값을, 어떤 경우엔 `string` 값을 출력할 수도 있다.
    - 이런 데이터를 출력하는데 있어 **여러가지 복잡한 기능은 시스템 콜에서 제공하고 있지 않다.**
    - **시스템 콜은 단지 화면에 이 값을 출력하라는 기능만을 제공할 뿐**이다.

- 시스템 콜은 **일반 프로그래머가 쓰기에 너무 단순**하기에 **일반 프로그래머에게 친숙한, 고수준의 함수 형태로 제공되는 서비스가 API**이다.

- API는 커널의 일부분이 아니고, **커널 서비스를 이용해 사용자에게 고차원의 서비스를 제공하는 라이브러리 형태**이다.
    - 사용성이 넓기 떄문에 일반 응용프로그램들은 시스템 콜보다는 API를 많이 사용하게 된다.

- API는 임의로 작성이 가능하긴 하지만, 다른 시스템에서도 동일한 동작을 수행해야 하기 때문에 표준을 따라야 한다.
    - 고로 여러 API는 표준의 형태로 많이 제공된다.
    - e.g. : `Win32 API`, `POSIX API`, `Mac OS`, `Java API` . . .

### 라이브러리 콜 (Library Call)

![image](https://user-images.githubusercontent.com/85336456/203785446-a921625b-1e66-47bb-8fb0-335e6cf6a0bd.png)

- 우리가 많이 사용해본 `printf` 라는 함수는, **직접 시스템 콜을 호출하는 것이 아니라 C 라이브러리를 한 단계 거쳐 시스템 콜을 호출하는 것**을 확인할 수 있다.

- 그렇다면 시스템 콜과 라이브러리 콜의 **차이**는 무엇일까?
    - 시스템 콜은 **하드웨어 접근을 목적**으로 커널 모드 진입을 요청하는 것을 의미한다.
    - 라이브러리 콜은 **프로그래밍 라이브러리에 정의된 기능에 접근을 목적**으로 요청하는 것을 의미한다.

- 물론 위 그림처럼, 라이브러리 콜을 사용하더라도 내부적으로 시스템 콜을 사용하는 것을 확인할 수 있다.
- **그렇다면 왜 굳이 라이브러리 콜을 한 단계 거치는 것일까?**
    - 시스템 콜의 호출 빈도가 많아지면 많은 시스템 리소스가 소모되고, **시스템 리소스의 소모량이 늘어나면서 성능이 저하**될 수 있다. (시스템 콜 양이 많은게 아니라 호출 빈도가 많을 때)
    - `fread()` , `fwrite()` 의 경우 내부적으로 버퍼에 데이터를 쌓았다가 일정 크기 이상이 되면 시스템 콜인 `read()`, `write()` 를 사용한다.
    - **시스템 콜의 호출 빈도를 확연하게 줄여 시스템 성능 저하를 막기 위해 라이브러리 콜을 거치는 것**이다.

### 시스템 콜 유형

- **프로세스 제어(Process Control)**
    - 끝내기(end), 중지(abort)
    - 적재(load), 실행(execute)
    - 프로세스 생성(create process)
    - 프로세스 속성 획득과 설정(get process attribute and set process attribute)
    - 시간 대기(wait time)
    - 사건 대기(wait event)
    - 사건을 알림(signal event)
    - 메모리 할당 및 해제 : malloc, free

- **파일 조작(File Manipulation)**
    - 파일 생성(create file), 파일 삭제(delete file)
    - 열기(open), 닫기(close)
    - 읽기(read), 쓰기(write), 위치 변경(reposition)
    - 파일 속성 획득 및 설정(get file attribute and set file attribute)

- **장치 관리(Devide Management)**
    - 장치를 요구(request devices), 장치를 방출release device)
    - 읽기, 쓰기, 위치 변경
    - 장치 속성 획득, 장치 속성 설정
    - 장치의 논리적 부착(attach) 또는 분리(detach)

- **정보 유지(Information Maintenance)**
    - 시간과 날짜의 설정과 획득(time)
    - 시스템 데이터의 설정과 획득(date)
    - 프로세스 파일, 장치 속성의 획득 및 설정

- **통신(Communication)**
    - 통신 연결의 생성, 제거
    - 메시지의 송신, 수신
    - 상태 정보 전달
    - 원격 장치의 부착 및 분리
    

**References**

- [https://www.youtube.com/watch?v=bjGIf_AKtAc&t=164s](https://www.youtube.com/watch?v=bjGIf_AKtAc&t=164s)
- [https://velog.io/@yh_lee/System-Call](https://velog.io/@yh_lee/System-Call)
- [https://coding-chobo.tistory.com/31](https://coding-chobo.tistory.com/31)
- [https://fjvbn2003.tistory.com/306](https://fjvbn2003.tistory.com/306)
- [https://luckyyowu.tistory.com/133](https://luckyyowu.tistory.com/133)
