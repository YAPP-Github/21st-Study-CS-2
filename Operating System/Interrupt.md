- CPU는 메모리로부터 명령어 혹은 데이터를 가지고 와서 실행한다.
    - 필요하다면, 값을 저장할 수 있다.

- CPU가 메모리에 저장되어 있는 **프로그램을 실행하는 과정**에는 **패턴**이 있다.
    - 다르게 얘기하면 **CPU는 메모리 안의 프로그램을 어떤 정해진 흐름대로만 처리하는 것**이다.
        
        **⇒ 그리고, 이 정해진 흐름 주기를 명령어 사이클이라고 부른다.**

![image](https://user-images.githubusercontent.com/85336456/202472903-71b45629-1c4e-466c-8a9d-b2d5c86c793f.png)

- **간혹 그 정해진 흐름을 방해 혹은 끊어버리는 신호가 CPU에 전달되는 경우**가 있다.
    
     → 이 신호를 **인터럽트(Interrupt)** 라고 부른다.
    

### 명령어 사이클(Command Cycle)

- **CPU**는 **일정 주기마다 프로그램 속 명령어들을 실행**한다.
    
    ⇒ 이 주기를 **명령어 사이클**이라고 칭한다.
    

![image](https://user-images.githubusercontent.com/85336456/202473123-3ac89cd0-3ec0-4557-8299-773bedd89088.png)


- **예를 들어 CPU가 메모리에 있는 프로그램을 실행한다고 가정**해보자.
    - 그렇다면 **CPU는 일단 어떤 작업을 먼저 실행**해야 할까?
        
        ⇒ **메모리에 있는 값을 CPU 레지스터 혹은 CPU 내부로 가져와야 한다. (인출)**
        
        ⇒ 그리고 **인출하는 주기를 인출 사이클**이라고 한다.
        
        > CPU가 메모리 안에 있는 어떤 프로그램을 실행하기 위해 메모리에 저장된 값을 CPU 내부로 가지고 오는 작업을 인출이라고 한다.
        > 
        
- 메모리에 저장된 값을 가져왔으면, 이제 실행해야 한다.
    
    ⇒ **실행 사이클**
    

![image](https://user-images.githubusercontent.com/85336456/202473247-f5877338-eec0-480e-8f05-b905518fb076.png)

- 일반적으로 **CPU는 인출 - 실행, 인출 - 실행, 인출 사이클과 실행 사이클이 반복되며 실행**된다.
    - 갖고와서 실행하고.. 갖고 와서 실행하고..

- 그런데, **CPU로 명령어를 가지고 와도 바로 실행이 불가능한 경우**도 있다.

![image](https://user-images.githubusercontent.com/85336456/202473303-d55cf0f4-a1f8-4025-9c96-85fd4ae1207d.png)


- 예로 위의 사진과 같은 명령어 주소 지정 방식이 있다.
    - 인출을 하면 바로 실행이 가능한 명령어도 있지만, 인출을 하더라도 바로 실행이 불가능한 경우가 있다.
        
        ⇒ **이런 경우 추가적으로 메모리에 접근**해야 한다. **(간접 주소 지정 방식)**
        
        ⇒ 이럴 때 **간접 사이클**이 추가될 수 있다.
        

![image](https://user-images.githubusercontent.com/85336456/202473415-80d12f49-d202-4a1c-be8b-152074f994a0.png)

- **인출을 한 후 메모리 접근이 더 필요한 경우 간접 사이클에 돌입**하게 된다.
    - 이 간접 사이클이 끝나 실행이 가능하게 되면 실행 사이클에 돌입하게 되는 것이다.

- 일반적으로 인터럽트라고 하는 개념이 없다면, CPU는 이 주기를 바탕으로 실행된다.

### 인터럽트(Interrupt)

- 방해하다, 중단시키다

![image](https://user-images.githubusercontent.com/85336456/202473477-2f214c03-39c4-463b-a401-18f5e93d7848.png)

- 위에서 말한 것처럼, 정해진 흐름대로 CPU가 명령어를 처리하고 있을 때 정해진 흐름을 끊어버리는 것을 인터럽트라고 한다.
    - **CPU가 꼭 주목해야 할 때** 혹은 **CPU가 빠르게 처리해야 할 다른 작업이 생겼을 때** 발생한다.

## 인터럽트의 종류

![image](https://user-images.githubusercontent.com/85336456/202473510-eb69b9f8-4133-4ea1-8d2a-a1d14022a165.png)

- 인터럽트의 종류에는 **동기 인터럽트**와 **비동기 인터럽트**가 있다.
    - 동기 인터럽트는 예외(Exception) 인터럽트라고도 부른다.
    - 비동기 인터럽트는 하드웨어 인터럽트라고도 부른다.

### 동기 인터럽트

![image](https://user-images.githubusercontent.com/85336456/202473572-22573da0-9f98-4ee2-8a9f-78f8d44c8fd4.png)

- 우리가 흔히 **예외**라고 부른다.
- **CPU가 예기치 못한 상황을 접했을 때 발생**한다.
    - e.g : **CPU가 실행을 중단하고 예외적인 상황을 먼저 처리해야 하는 상황**
        - 메모리 주소에 접근했는데 원하는 데이터가 없을 때
        - 0으로 나눌 때 (Division by zero)
        - 실행할 수 없는 명령어가 있을 때
        - 산술 오버플로우, 언더플로우

### 동기 인터럽트의 종류

![image](https://user-images.githubusercontent.com/85336456/202473609-548ff5af-6cb3-4a68-ae79-3427755e2d60.png)

- **폴트, 트랩, 중단** 등이 있다.

- **트랩(Trap)**
    - 소프트웨어 인터럽트, 내부 인터럽트로 **사용자가 의도적으로 발생시키는 것**을 의미한다.
    - 예외라고 하기엔 애매한 부분이 있다.
    - `System call` 과 같이 커널을 호출하는 경우에 나타난다.

- **폴트(Fault)**
    - 사용자의 의도에 의해 발생되는 것이 아니라, **어떠한 문제가 있어서 발생**한다.
    - 이 경우 핸들러에 의해 처리될 수 있다고 판단되고, 다시 현재 명령어로 돌아가게 된다.
    - 예로 `Page Fault` 와 같은 복구할 수 있는 예외들이 있다.

- **중단(Abort)**
    - 폴트와 달리 **복구할 수 없는 예외**를 칭한다.
    - 복구할 수 없으므로 프로세스를 종료하여 이를 처리한다.

### 비동기 인터럽트

![image](https://user-images.githubusercontent.com/85336456/202473647-d9b7e9f3-2f54-4788-9811-7e1368b1e13d.png)

- 우리가 흔히 **인터럽트**라고 불리는 종류이다.
- **주로 입출력장치에 의해 발생**한다.
    - **즉, 다른 하드웨어가 보내주는 인터럽트**라고 볼 수 있다.
    - 어떤 문제라기보다는 **알림과 같은 역할**이라고 볼 수 있다.
        - 세탁기가 완료되면 알림을 주는 것처럼, 하드웨어가 알림을 주는 것이다.
        - CPU가 프린터에게 프린트 명령을 내리고 다른 일을 한다고 가정해보자.
        - 프린트는 입출력 작업이 완료되면 CPU에게 **알림과 같은 하드웨어 인터럽트**를 보내는 것이다.

![image](https://user-images.githubusercontent.com/85336456/202473687-74905ae9-4101-4947-97ac-40234a533f0a.png)

- 프린터뿐 아니라 다른 입력 장치도 마찬가지이다.
    - 키보드로 어떤 값을 입력하거나 마우스로 클릭하는 것 역시 인터럽트의 한 종류이다.
    - CPU에게 전달이 되면, CPU가 인지 후 어떤 입력인지 확인 후 이에 맞는 처리를 진행한다.

- **입출력 작업 도중에도 효율적으로 명령어를 처리**하기 위해 하드웨어 인터럽트를 사용한다.
    - 왜 효율적으로 처리할 수 있을까?
        
        ![image](https://user-images.githubusercontent.com/85336456/202473736-8623c8be-4e91-42c8-ae79-cd01d94595cb.png)
        
        - 입출력장치는 기본적으로 CPU에 비해 느리다.
        - 인터럽트가 없다면, CPU는 프린트 완료 여부를 확인하기 위해 주기적으로 확인해야 한다.
        - 인터럽트가 있다면 **CPU는 일을 프린터에 맡겨 놓고 다른 일을 하러가면 된다.**

### 하드웨어 인터럽트의 처리 순서

- 인터럽트 종류를 막론하고 인터럽트 처리 순서는 대동소이하다.

1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 요청 확인 후 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지에 대한 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 **(4)**에서 백업해 둔 작업을 복구하여 실행을 재개한다.

### 인터럽트 요청 신호

![image](https://user-images.githubusercontent.com/85336456/202473797-78ea417a-7e15-488d-85f8-c87e3dfd58f2.png)

- **하드웨어 인터럽트를 보내는 주체**, 예를 들어 입출력장치들이 CPU에게 지금 끼어들어도 되는지 요청을 보내는 것을 의미한다.
- 인터럽트 자체가 CPU의 정상적 실행 흐름을 끊어버리는 것이기 때문에 **항상 인터럽트를 보내는 주체는 인터럽트 요청 신호를 CPU에게 전송해야 한다.**

### 인터럽트 플래그

![image](https://user-images.githubusercontent.com/85336456/202473842-35984e75-3062-4d95-a88a-d6d48d70e6aa.png)

- CPU가 인터럽트 요청 신호를 받아들였으면, 실행 사이클이 끝나고 항상 **플래그 레지스터 속의 인터럽트 플래그를 확인**한다.
- **인터럽트 플래그는 현재 인터럽트를 받아들일 수 있는지, 없는지에 대한 여부를 표기**한다. (0과 1로)
    - 인터럽트를 받아들일 수 있는 상태라면 CPU는 해당 인터럽트 요청을 받아들이고 인터럽트를 처리한다.
    - 받아들일 수 없다면, 인터럽트 요청 신호가 오더라도 인터럽트를 처리하지 않는다.

![image](https://user-images.githubusercontent.com/85336456/202473867-9be433dc-9e0f-4a77-8203-9bce6ff322a7.png)

- 유의할 점은, **모든 인터럽트를 인터럽트 플래그로 막을 수 없다는 것**이다.
    - 일부 인터럽트 중에는 하드웨어 고장이라던지, 정전이라던지와 같은 꼭 처리해야 하는 긴급한 인터럽트들이 있다.
    - 이러한 인터럽트는 인터럽트 플래그로 막을 수 없다. (**NMI**, non maskable interrupt)

### 인터럽트 서비스 루틴

- **CPU가 인터럽트를 받아들이기로 했다면 인터럽트 서비스 루틴이라는 프로그램을 실행**한다.
    - 인터럽트 서비스 루틴도 메모리 안에서 돌아가는 **프로그램 중 하나**이다.
- 인터럽트 발생시 **해당 인터럽트를 어떻게 처리할 수 있는지에 대해 적혀있는 프로그램**이다.
    - 키보드가 인터럽트 요청을 보내면 이렇게 행동해야 한다.
    - 마우스가 인터럽트 요청을 보내면 이렇게 행동해야 한다.

![image](https://user-images.githubusercontent.com/85336456/202473918-cfa1e056-83d7-49e2-a364-8398a54df4ef.png)

- 인터럽트 서비스 루틴 또한 프로그램이기 때문에, 메모리에 저장되어 있다.
    - 그리고, 인터럽트를 보내는 주체에 따라 **각기 다른 인터럽트 서비스 루틴의 시작 주소**를 가지고 있다.

![image](https://user-images.githubusercontent.com/85336456/202473944-42be1b2d-89ba-468f-9db1-83380b4329af.png)

- **CPU는 자기가 실행 중인 프로그램을 쭉 실행하다가, 인터럽트가 발생하면 해당 명령어까지는 실행을 끝내고 그 인터럽트로 되돌아가 그 인터럽트를 실행한 후 다시 되돌아와 수행을 재개**하게 된다.

### 인터럽트 벡터

![image](https://user-images.githubusercontent.com/85336456/202473973-7f9fa597-746d-47e2-ac5b-addb3b51f736.png)

- **인터럽트를 보낼 수 있는 주체**엔 여러 개가 있다.
    - 프린터, 마우스, 키보드 등. . .
    - 이들 모두 **각기 다른 인터럽트 서비스 루틴 주소**를 가지고 있다.
    - 다시 말해, **인터럽트마다 고유한 인터럽트 서비스 루틴의 시작 주소**를 가지고 있다.
- **각각의 인터럽트를 구분하기 위한 정보를 인터럽트 벡터**라고 부른다.
    - **CPU가 해당 인터럽트 서비스 루틴의 시작 주소를 인지하기 위해 인터럽트 벡터를 필요로 한다.**
- 인터럽트 벡터들을 표처럼 모아놓은 인터럽트 벡터 테이블도 메모리에 위치하고 있다.
- 보통 인터럽트를 보내는 주체는 해당 인터럽트 요청 신호와 함께 인터럽트 벡터도 데이터 버스를 통해 전송한다.

### 짧게 정리

- ‘CPU가 인터럽트를 처리한다’
    
    ⇒ ‘인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다.’
    
    - 그리고 인터럽트의 시작 주소는 인터럽트 벡터를 통해 알 수 있다.

![image](https://user-images.githubusercontent.com/85336456/202474017-92451329-4fea-47ea-a877-5c8768e396b1.png)

### 문제점

- 그런데, 여기서 문제가 있다.
    - CPU가 실행 프로그램을 쭉 실행하다가 인터럽트가 발생하면 해당 인터럽트 서비스 루틴으로 점프해서 마저 실행하고 되돌아온다고 이야기했다.
    - 이 프로그램을 실행하는 과정에서도 프로그램 카운터, 여러 레지스터 값들이 CPU에 저장되어 있을 것이다.
- **그럼, 이 정보들을 버려야 할까?**
    - 인터럽트 서비스 루틴을 실행하게 되면 프로그램 카운터를 1500에서 10으로 바꿔야하나?
    - 언제든 다시 되돌아와서 수행을 재개해야 하기 때문에 **현재 레지스터에는 어떤 값들이 담겨있는지, 현재 CPU는 어떤 상태인지에 대해 기억을 해야한다.**
    - 그렇다면 지금까지 했던 작업을 어딘가에 백업을 하고 그 다음에 인터럽트 서비스 루틴을 실행하며 여러 레지스터 값들을 사용해야 한다.
    - 인터럽트 서비스 루틴 역시 프로그램이므로 당연히 여러 레지스터를 사용한다.
    - 그 전에 담겨있던 레지스터 값들은 백업을 해야한다.

- 백업을 하기 위해 지금까지의 작업 내용, 즉 **레지스터 안에 담겨있는 값을 모두 스택에 백업**을 하게 된다.
- 이 과정을 거친 후에야 인터럽트 서비스 루틴을 실행할 수 있게 되면서, 인터럽트 서비스 루틴의 정보를 레지스터에 담게 된다.
- **인터럽트 서비스 루틴 실행이 종료되면 스택에 저장한 이전 작업을 모두 복구한다.**

---

### 주요 키워드 정리

- **인터럽트 요청 신호** : CPU의 작업을 방해하는 인터럽트에 대한 요청
- **인터럽트 플래그** : 인터럽트 요청 신호를 받아들일지, 무시할지를 결정하는 비트
- **인터럽트 벡터** : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
- **인터럽트 서비스 루틴** : 인터럽트를 처리하는 프로그램

![image](https://user-images.githubusercontent.com/85336456/202474068-fdacc2c2-b38e-4430-b1d2-1931bd893af2.png)

- 인터럽트가 발생한 상황까지 추가한 추가된 명령어 사이클은 위의 그림과 같다.
- 이러한 정형화된 주기에 따라 CPU는 명령어를 처리한다.

### Reference

[https://www.youtube.com/watch?v=3Yz7OnVUM28](https://www.youtube.com/watch?v=3Yz7OnVUM28)
